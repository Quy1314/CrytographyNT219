
# üîí Exporting a C++ AES Library and Importing It in Java Using JNI

This guide walks you through exporting AES cryptographic functions from a C++ library using Crypto++, and importing them into Java using JNI.

---

## üì¶ Step 1: Write Your Native C++ Code

You already have the following AES C++ library with functions exported using `__declspec(dllexport)` or plain `EXPORT` on Linux. It contains:

- `GenerateAESKey`
- `SaveKeyToFile`
- `LoadKeyFromFile`
- `AESEncryptFile`
- `AESDecryptFile`

Make sure it uses:

```cpp
extern "C" {
    EXPORT void __cdecl GenerateAESKey(byte *key, byte *iv);
    ...
}
```

---

## üèóÔ∏è Step 2: Compile Your C++ Code into a Shared Library

### On Windows (MinGW):
```sh
g++ -shared -o AES.dll AES.cpp -lcryptopp
```

### On Linux:
```sh
g++ -fPIC -shared -o libAES.so AES.cpp -lcryptopp
```

---

## üß¨ Step 3: Create a Java Class with Native Methods

```java
public class AESInterop {
    static {
        System.loadLibrary("AES");  // Do NOT include .dll/.so
    }

    public native void GenerateAESKey(byte[] key, byte[] iv);
    public native void SaveKeyToFile(String filename, byte[] key, byte[] iv);
    public native void LoadKeyFromFile(String filename, byte[] key, byte[] iv);
    public native void AESEncryptFile(String inputFilename, String outputFilename, byte[] key, byte[] iv);
    public native void AESDecryptFile(String inputFilename, String outputFilename, byte[] key, byte[] iv);
}
```

---

## üßæ Step 4: Compile Java and Generate JNI Header

```sh
javac AESInterop.java
javac -h . AESInterop.java
```

This will produce `AESInterop.h`, which contains the JNI function signatures Java expects.

---

## üõ†Ô∏è Step 5: Implement the JNI Wrapper in C++

Create `AESInteropJNI.cpp`:

```cpp
#include "AESInterop.h"
#include "AES.cpp" // or use a header file with declarations
#include <jni.h>

extern "C" {

JNIEXPORT void JNICALL Java_AESInterop_GenerateAESKey(JNIEnv *env, jobject, jbyteArray key, jbyteArray iv) {
    jbyte* keyPtr = env->GetByteArrayElements(key, NULL);
    jbyte* ivPtr = env->GetByteArrayElements(iv, NULL);
    GenerateAESKey(reinterpret_cast<byte*>(keyPtr), reinterpret_cast<byte*>(ivPtr));
    env->ReleaseByteArrayElements(key, keyPtr, 0);
    env->ReleaseByteArrayElements(iv, ivPtr, 0);
}

// Repeat for all other methods

}
```

---

## üß™ Step 6: Compile the JNI DLL/SO

### Windows (MinGW):
```sh
g++ -I%JAVA_HOME%/include -I%JAVA_HOME%/include/win32 -shared -o AES.dll AESInteropJNI.cpp AES.cpp -lcryptopp
```

### Linux:
```sh
g++ -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared -o libAES.so AESInteropJNI.cpp AES.cpp -lcryptopp
```

---

## üöÄ Step 7: Run Your Java Application

Make sure `AES.dll` or `libAES.so` is in your current directory or library path.

```sh
java -Djava.library.path=. AESInterop
```

Example:
```sh
java -Djava.library.path=. AESInterop generate keyfile.bin
```

---

## ‚úÖ Notes

- Library name in Java is **`AES`**, but the actual file should be:
  - `AES.dll` on Windows
  - `libAES.so` on Linux

- Ensure JNI method names **exactly** match `Java_<ClassName>_<MethodName>` as shown in the generated `.h` file.

---

Happy JNI bridging! Let me know if you want a full working example with Java + native + test files.
